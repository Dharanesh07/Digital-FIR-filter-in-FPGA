module fir_multiplex #(
    parameter DATA_WIDTH = 16,
    parameter TAP_WIDTH = 16,
    parameter TAP_COUNT = 65,
    parameter MUL_PER_CYCLE = 8
) (
    input wire i_clk,
    input wire i_rstn,
    input wire i_fir_valid,
    input wire signed [DATA_WIDTH-1:0] i_fir_datain,
    output reg signed [(2*DATA_WIDTH)-1:0] o_fir_dataout,
    output reg o_fifo_wren,
    input wire sig_comp
);

  localparam ACC_WIDTH = 2 * DATA_WIDTH;
  //65/8 = 8.125 which equals to 9 cycles
  //We need 9 cycles to process 65 taps with 8 multipliers
  localparam NUM_OF_CYCLES = (TAP_COUNT + MUL_PER_CYCLE - 1) / MUL_PER_CYCLE;

  reg signed [TAP_WIDTH-1:0] coeff[TAP_COUNT-1:0];
  reg signed [DATA_WIDTH-1:0] delay_line[0:TAP_COUNT-1];
  reg signed [(ACC_WIDTH-1):0] accumulator;
  reg signed [(ACC_WIDTH-1):0] mult_results[0:MUL_PER_CYCLE-1];

  reg [$clog2(NUM_OF_CYCLES):0] cycle_count;
  reg processing;
  reg accumulate_now;
  integer i;

  always @(posedge i_clk) begin
    if (!i_rstn) begin
      // Reset logic
      accumulator <= 0;
      cycle_count <= 0;
      processing <= 0;
      o_fifo_wren <= 0;
      o_fir_dataout <= 0;
      accumulate_now <= 0;
      coeff[0] <= 32'b00000000000001010111000010000010;
      coeff[1] <= 32'b00000000000001111111101010100000;
      coeff[2] <= 32'b00000000000010100101011010011011;
      coeff[3] <= 32'b00000000000011000000001001101101;
      coeff[4] <= 32'b00000000000011000110011100010111;
      coeff[5] <= 32'b00000000000010101110100101101000;
      coeff[6] <= 32'b00000000000001101111001001100011;
      coeff[7] <= 32'b00000000000000000000000000000000;
      coeff[8] <= 32'b11111111111101011011101000101100;
      coeff[9] <= 32'b11111111111010000000101111101101;
      coeff[10] <= 32'b11111111110101110001111100110110;
      coeff[11] <= 32'b11111111110000111000011011010011;
      coeff[12] <= 32'b11111111101011100001110011011110;
      coeff[13] <= 32'b11111111100110000001101111101011;
      coeff[14] <= 32'b11111111100000110000000110101000;
      coeff[15] <= 32'b11111111011100000111111000010111;
      coeff[16] <= 32'b11111111011000100100110111010011;
      coeff[17] <= 32'b11111111010110100011000110100101;
      coeff[18] <= 32'b11111111010110011010011100111011;
      coeff[19] <= 32'b11111111011000011101010000110000;
      coeff[20] <= 32'b11111111011100110111010101000011;
      coeff[21] <= 32'b11111111100011101010011111001110;
      coeff[22] <= 32'b11111111101100101110010110011011;
      coeff[23] <= 32'b11111111110111110000100100001111;
      coeff[24] <= 32'b00000000000100010100110100101111;
      coeff[25] <= 32'b00000000010001110110101011111001;
      coeff[26] <= 32'b00000000011111101010010111111000;
      coeff[27] <= 32'b00000000101101000010000000101110;
      coeff[28] <= 32'b00000000111001001101101000001010;
      coeff[29] <= 32'b00000001000011100001011100011010;
      coeff[30] <= 32'b00000001001011010110111011001110;
      coeff[31] <= 32'b00000001010000010000001100000000;
      coeff[32] <= 32'b00000001010001111010111000010100;
      coeff[33] <= 32'b00000001010000010000001100000000;
      coeff[34] <= 32'b00000001001011010110111011001110;
      coeff[35] <= 32'b00000001000011100001011100011010;
      coeff[36] <= 32'b00000000111001001101101000001010;
      coeff[37] <= 32'b00000000101101000010000000101110;
      coeff[38] <= 32'b00000000011111101010010111111000;
      coeff[39] <= 32'b00000000010001110110101011111001;
      coeff[40] <= 32'b00000000000100010100110100101111;
      coeff[41] <= 32'b11111111110111110000100100001111;
      coeff[42] <= 32'b11111111101100101110010110011011;
      coeff[43] <= 32'b11111111100011101010011111001110;
      coeff[44] <= 32'b11111111011100110111010101000011;
      coeff[45] <= 32'b11111111011000011101010000110000;
      coeff[46] <= 32'b11111111010110011010011100111011;
      coeff[47] <= 32'b11111111010110100011000110100101;
      coeff[48] <= 32'b11111111011000100100110111010011;
      coeff[49] <= 32'b11111111011100000111111000010111;
      coeff[50] <= 32'b11111111100000110000000110101000;
      coeff[51] <= 32'b11111111100110000001101111101011;
      coeff[52] <= 32'b11111111101011100001110011011110;
      coeff[53] <= 32'b11111111110000111000011011010011;
      coeff[54] <= 32'b11111111110101110001111100110110;
      coeff[55] <= 32'b11111111111010000000101111101101;
      coeff[56] <= 32'b11111111111101011011101000101100;
      coeff[57] <= 32'b00000000000000000000000000000000;
      coeff[58] <= 32'b00000000000001101111001001100011;
      coeff[59] <= 32'b00000000000010101110100101101000;
      coeff[60] <= 32'b00000000000011000110011100010111;
      coeff[61] <= 32'b00000000000011000000001001101101;
      coeff[62] <= 32'b00000000000010100101011010011011;
      coeff[63] <= 32'b00000000000001111111101010100000;
      coeff[64] <= 32'b00000000000001010111000010000010;

      for (i = 0; i < TAP_COUNT; i = i + 1) begin
        delay_line[i] <= 0;
      end

      for (i = 0; i < MUL_PER_CYCLE; i = i + 1) begin
        partial_sum[i] <= 0;
      end
    end else begin
      o_fifo_wren <= 0;

      if (i_fir_valid && !processing) begin
        // Load new sample into delay line
        delay_line[0] <= i_fir_datain;
        for (i = 1; i < TAP_COUNT; i = i + 1) begin
          delay_line[i] <= delay_line[i-1];
        end
        accumulator <= 0;
        cycle_count <= 0;
        processing  <= 1;
      end

      if (processing) begin
        // Perform multiplications using DSP blocks
        for (i = 0; i < MUL_PER_CYCLE; i = i + 1) begin
          if (cycle_count * MUL_PER_CYCLE + i < TAP_COUNT) begin
            mult_results[i] <= $signed(delay_line[cycle_count*MUL_PER_CYCLE+i]) *
                $signed(coeff[cycle_count*MUL_PER_CYCLE+i]);
          end else begin
            mult_results[i] <= 0;
          end
        end

        // Accumulate results
        accumulator <= accumulator + 
                      mult_results[0] + mult_results[1] + mult_results[2] + mult_results[3] +
                      mult_results[4] + mult_results[5] + mult_results[6] + mult_results[7];

        if (cycle_count == NUM_OF_CYCLES - 1) begin
          o_fir_dataout <= accumulator;
          o_fifo_wren <= ~sig_comp;
          processing <= 0;
        end else begin
          cycle_count <= cycle_count + 1;
        end
      end
    end
  end
endmodule
/*
Clock Cycle 1: [ Tap  0  Tap  1  Tap  2  Tap  3  Tap  4  Tap  5  Tap  6  Tap  7 ]
Clock Cycle 2: [ Tap  8  Tap  9  Tap 10  Tap 11  Tap 12  Tap 13  Tap 14  Tap 15 ]
Clock Cycle 3: [ Tap 16  Tap 17  Tap 18  Tap 19  Tap 20  Tap 21  Tap 22  Tap 23 ]
Clock Cycle 4: [ Tap 24  Tap 25  Tap 26  Tap 27  Tap 28  Tap 29  Tap 30  Tap 31 ]
Clock Cycle 5: [ Tap 32  Tap 33  Tap 34  Tap 35  Tap 36  Tap 37  Tap 38  Tap 39 ]
Clock Cycle 6: [ Tap 40  Tap 41  Tap 42  Tap 43  Tap 44  Tap 45  Tap 46  Tap 47 ]
Clock Cycle 7: [ Tap 48  Tap 49  Tap 50  Tap 51  Tap 52  Tap 53  Tap 54  Tap 55 ]
Clock Cycle 8: [ Tap 56  Tap 57  Tap 58  Tap 59  Tap 60  Tap 61  Tap 62  Tap 63 ]
Clock Cycle 9: [ Tap 64 (only 1 tap left) ------------------------------ (empty) ]
*/

